<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Backbone.js Patterns Pt.2: Don’t make me think</title>
  <meta name="description" content="Different programming languages have different naming conventions. When working with Ruby, for example, it is advised that you separate multi-word variables ...">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/2013/08/29/backbone-js-patterns-pt-2-don-t-make-me-think.html">
  <link rel="alternate" type="application/rss+xml" title="Dom Christie" href="http://localhost:4000/feed.xml">
</head>

  <body>
    <header role="banner" class="navigation">
  <nav>
    <a href="/" title="Dom Christie Home (Recent Posts)">
      <img src="/domchristie.jpg" alt="" width="24" height="24" />
      <span class="name">Dom Christie</span>
    </a>
    <ul>
      
        
        <li><a href="/about/">About</a></li>
        
      
        
      
        
      
        
      
        
      
      <li><a href="/feed.xml">RSS</a></li>
    </ul>
  </nav>
</header>

    <main class="container">
      <div class="post-navigation">
  <a href="/"><span aria-label="Back to">←</span> Posts</a>
</div>

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post__header">
    <time datetime="2013-08-29T09:29:51+01:00" itemprop="datePublished">
      
        29 Aug 2013
      
    </time>

    
      <h1 itemprop="name headline">
        
          Backbone.js Patterns Pt.2: Don’t make me think
        
      </h1>
    
  </header>
  <div class="post__body" itemprop="articleBody">
    <p>Different programming languages have different naming conventions. When working with Ruby, for example, it is advised that you separate multi-word variables with underscores. In JavaScript, camelCasing is generally the norm. So when dealing with data that is shared across different environments, you may find yourself having to remember what style to use, e.g. <em>&#x201C;Was it <code>user.get(&apos;first_name&apos;)</code>, or <code>user.get(&apos;firstName&apos;)</code>?&#x201D;</em>.</p>

<p>This is where <strong>humps</strong> is your friend.</p>

<p><a href="https://github.com/domchristie/humps">humps</a> is a small JavaScript library (~100 LoC) that simply converts underscored object keys (and strings) to camelCased, and vice versa (as well as other styles, like PascalCase). By using humps in the <code>toJSON</code> and <code>parse</code> methods, we can seamlessly work with the conventions of each language.</p>

<p><code>toJSON</code> and <code>parse</code> are methods that are typically used to customise the data being sent to and from the server. <code>toJSON</code> should be used to prepare a model&#x2019;s attributes for synchronisation <sup><a href="#fn79.1" id="r79.1">[1]</a></sup>; whereas <code>parse</code> is typically called when data is sent <em>from</em> the server, and therefore can be used to prepare a model&#x2019;s attributes before they are set on the model itself.</p>

<p>Starting with the <code>parse</code> method, overwrite <code>Backbone.Model.prototype.parse</code>, passing the results of the old `parse` method into <code>humps.camelizeKeys</code>:</p>

<pre><code>(function() {
  var oldParse = Backbone.Model.prototype.parse;
  Backbone.Model.prototype.parse = function() {
    var parsed = oldParse.apply(this, arguments);
    return humps.camelizeKeys(parsed);
  };
})();
</code></pre>

<p>So now, the following JSON:</p>

<pre><code>{ &quot;first_name&quot;: &quot;Jon&quot;, &quot;last_name&quot;: &quot;Snow&quot;, &quot;is_steward&quot;: true }
</code></pre>

<p>will be converted to camelCase and will be accessible on the model as follows:</p>

<pre><code>// assuming user is an instance of a Backbone model
user.get(&apos;firstName&apos;); // &quot;Jon&quot;
user.get(&apos;lastName&apos;); // &quot;Snow&quot;
user.get(&apos;isSteward&apos;); // true
</code></pre>

<p>Remember, that <code>parse</code> is only called when a model&#x2019;s is updated via a <code>fetch</code> or <code>save</code>. If you are populating a model&#x2019;s attributes manually, you&#x2019;ll need to pass in <code>{ parse: true }</code>:</p>

<pre><code>var user = new User({
  &quot;first_name&quot;: &quot;Jon&quot;
}, { parse: true });
</code></pre>

<p>It&#x2019;ll also work with nested objects.</p>

<p>The same pattern can be applied to <code>toJSON</code>, which will convert camelCased object keys (back) to underscored:</p>

<pre><code>(function() {
  var oldToJSON = Backbone.Model.prototype.toJSON;
  Backbone.Model.prototype.toJSON = function() {
    var json = oldToJSON.apply(this, arguments);
    return humps.decamelizeKeys(json);
  };
})();
</code></pre>
<p>Feedback welcome via <a href="https://twitter.com/domchristie">Twitter</a>, or <a href="mailto:christiedom@gmail.com">email</a>.</p>
<p>Part 3 in this miniseries will extend the <code>toJSON</code> method to exclude non-persisted attributes from its output.</p>

<section class="footnotes">
  <p id="fn79.1"><a href="#r79.1">[1]</a> The Backbone.js documentation for <code>toJSON</code> previously suggested that it could be used to clone a model&#x2019;s attributes for use in a template, as well as for persistence. Following a <a href="https://github.com/jashkenas/backbone/issues/2134">discussion on the purpose of <code>toJSON</code></a>, it was decided that this &#x201C;double duty&#x201D; should be simplified. It is now not recommended for preparing a model for rendering.</p>
</section>
  </div>
</article>


<div class="post-navigation post-navigation--older-newer">
  
    <a class="post-navigation__older" href="/2013/08/21/backbone-js-patterns-pt-1-maintaining-the-uniform-access-principle.html">Previous Post</a>
  
  
    <a class="post-navigation__newer" href="/2013/09/11/watch.html">Next post</a>
  
</div>


    </main>
  </body>
</html>
